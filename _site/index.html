<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Cubes Blog</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>New Cubes Blog | A blog featuring interactive 3D visualizations</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="New Cubes Blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A blog featuring interactive 3D visualizations" />
<meta property="og:description" content="A blog featuring interactive 3D visualizations" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="New Cubes Blog" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="New Cubes Blog" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"A blog featuring interactive 3D visualizations","headline":"New Cubes Blog","name":"New Cubes Blog","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1 class="site-title"><a href="/">New Cubes Blog</a></h1>
            <nav class="site-nav">
                <a href="/">Home</a>
                <a href="/blog">Blog</a>
            </nav>
        </div>
    </header>

    <main class="site-content">
        <div class="container">
            <div id="container"></div>
<div id="blog-overlay" class="hidden">
    <div class="blog-content">
        <div class="close-button">&times;</div>
        <div id="blog-text"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to the Interactive Cubes Blog - New Cubes Blog</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Welcome to the Interactive Cubes Blog | New Cubes Blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Welcome to the Interactive Cubes Blog" />
<meta name="author" content="Sergy S." />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Welcome to the Interactive Cubes Blog!" />
<meta property="og:description" content="Welcome to the Interactive Cubes Blog!" />
<link rel="canonical" href="http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/" />
<meta property="og:url" content="http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/" />
<meta property="og:site_name" content="New Cubes Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-04-09T00:00:00+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Welcome to the Interactive Cubes Blog" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sergy S."},"dateModified":"2024-04-09T00:00:00+03:00","datePublished":"2024-04-09T00:00:00+03:00","description":"Welcome to the Interactive Cubes Blog!","headline":"Welcome to the Interactive Cubes Blog","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/"},"url":"http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1 class="site-title"><a href="/">New Cubes Blog</a></h1>
            <nav class="site-nav">
                <a href="/">Home</a>
                <a href="/blog">Blog</a>
            </nav>
        </div>
    </header>

    <main class="site-content">
        <div class="container">
            <article class="post">
  <header class="post-header">
    <h1 class="post-title">Welcome to the Interactive Cubes Blog</h1>
    <p class="post-meta">
      <time datetime="2024-04-09T00:00:00+03:00">
        April 9, 2024
      </time>
    </p>
  </header>

  <div class="post-content">
    <h1 id="welcome-to-the-interactive-cubes-blog">Welcome to the Interactive Cubes Blog!</h1>

<p>You’ve found the special red cube! This is your gateway to exploring our blog about Three.js, WebGL, and creative coding.</p>

<h2 id="about-this-project">About This Project</h2>

<p>This blog combines interactive 3D visualizations with written content. The main page features thousands of floating cubes, with one special red cube that leads you here. This interaction demonstrates the power of Three.js for creating engaging web experiences.</p>

<h2 id="how-it-works">How It Works</h2>

<p>The cube visualization you just interacted with uses several advanced Three.js features:</p>

<ol>
  <li><strong>GPU Picking</strong> - To detect which cube you’re hovering over</li>
  <li><strong>Custom Shaders</strong> - For efficient rendering of thousands of cubes</li>
  <li><strong>TrackballControls</strong> - For smooth camera movement</li>
  <li><strong>Merged Geometries</strong> - For optimal performance</li>
</ol>

<h2 id="stay-connected">Stay Connected</h2>

<p>Keep exploring the cubes and check back for more posts about:</p>
<ul>
  <li>Three.js tutorials</li>
  <li>WebGL optimization tips</li>
  <li>Creative coding techniques</li>
  <li>Interactive web experiences</li>
</ul>

<p>Feel free to click around and discover more about 3D graphics on the web!</p>

  </div>
</article>

<div class="post-navigation">
  
  
</div> 
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 New Cubes Blog. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> </div>
    </div>
</div>

<div id="cube-menu">
    <div class="menu-title"></div>
    <div class="menu-brief"></div>
    <div class="menu-metadata">
        <span class="author"></span>
        <span class="date"></span>
    </div>
    <button id="read-button">Read</button>
</div>

<style>
#container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#blog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#blog-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.blog-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.close-button {
    position: fixed;
    top: 90px;
    right: 20px;
    font-size: 18px;
    cursor: pointer;
    width: 32px;
    height: 32px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: rgba(0, 0, 0, 0.7);
    color: rgba(255, 255, 255, 0.9);
    z-index: 1000;
    transition: all 0.2s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(4px);
}

.close-button:hover {
    background: rgba(0, 0, 0, 0.9);
    color: white;
    transform: scale(1.05);
    border-color: rgba(255, 255, 255, 0.2);
}

#cube-menu {
    display: none;
    position: fixed;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    z-index: 1000;
    min-width: 250px;
    max-width: 350px;
    box-sizing: border-box;
}

@media (max-width: 768px) {
    #cube-menu {
        width: calc(100% - 40px);
        max-width: 350px;
        min-width: unset;
        left: 20px;
        right: 20px;
        margin: 0 auto;
    }
}

#cube-menu .menu-title {
    color: white;
    font-size: 18px;
    margin-bottom: 8px;
    font-weight: 600;
    line-height: 1.4;
}

#cube-menu .menu-brief {
    color: rgba(255, 255, 255, 0.9);
    font-size: 14px;
    margin-bottom: 15px;
    line-height: 1.5;
}

#cube-menu .menu-metadata {
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    margin-bottom: 15px;
    line-height: 1.4;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 12px;
}

#cube-menu .menu-metadata span {
    display: block;
}

#cube-menu button {
    display: block;
    width: 100%;
    padding: 15px;
    margin: 0 auto;
    border: none;
    border-radius: 5px;
    background: #ff3333;
    color: white;
    font-size: 18px;
    cursor: pointer;
    transition: background 0.3s;
    text-align: center;
}

#cube-menu button:hover {
    background: #cc0000;
}
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

    let container, stats;
    let camera, controls, scene, renderer;
    let pickingTexture, pickingScene;
    let highlightBox;
    let pickedId = -1;
    let selectedCubeId = -1;  // Track the currently selected cube
    let lastInteractionTime = 0;
    const INTERACTION_TIMEOUT = 500; // Time window for second interaction (ms)
    const fragments = [];
    const gravity = new THREE.Vector3(0, -0.015, 0);
    let lastTime = 0;
    const pickingData = [];
    const pointer = new THREE.Vector2();
    const offset = new THREE.Vector3(10, 10, 10);
    const clearColor = new THREE.Color();
    
    // Auto-rotation variables
    let autoRotating = true;
    const INACTIVITY_TIMEOUT = 10000; // 10 seconds
    const autoRotationSpeed = 0.0002; // Slow rotation speed
    
    function startAutoRotation() {
        autoRotating = true;
        // Close menu when auto-rotation starts
        closeMenu();
    }
    
    function stopAutoRotation() {
        autoRotating = false;
        lastInteractionTime = Date.now();
    }

    function closeMenu() {
        const menu = document.getElementById('cube-menu');
        menu.style.display = 'none';
        selectedCubeId = -1;
        highlightBox.visible = false;
    }

    function checkInactivity() {
        if (!autoRotating && Date.now() - lastInteractionTime > INACTIVITY_TIMEOUT) {
            startAutoRotation();
        }
    }

    class Fragment {
        constructor(geometry, material, position, velocity, rotation, customGravity = gravity) {
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);
            this.velocity = velocity;
            this.rotation = rotation;
            this.gravity = customGravity;
            scene.add(this.mesh);
        }

        update() {
            this.velocity.add(this.gravity);
            this.mesh.position.add(this.velocity);
            this.mesh.rotation.x += this.rotation.x;
            this.mesh.rotation.y += this.rotation.y;
            this.mesh.rotation.z += this.rotation.z;

            // Remove if fallen below certain point
            if (this.mesh.position.y < -2000) {
                scene.remove(this.mesh);
                return true;
            }
            return false;
        }
    }

    // Define blog post mappings
    const cubeBlogMappings = {
        42: {
            title: "Welcome to the Interactive Cubes Blog",
            author: "Sergy S.",
            date: "April 9, 2024",
            brief: "Explore the world of interactive 3D web graphics through this unique cube-based interface. Click to discover more about Three.js and creative coding.",
            url: "/blog/2024/04/09/welcome-to-new-cubes-blog/",
            color: 0xff0000
        }
        // Add more mappings here for other cubes and posts
    };

    init();
    setupOverlays();

    function setupOverlays() {
        setupBlogOverlay();
        setupCubeMenu();
    }

    function setupBlogOverlay() {
        const overlay = document.getElementById('blog-overlay');
        const closeButton = document.querySelector('.close-button');
        
        closeButton.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });
    }

    function setupCubeMenu() {
        const menu = document.getElementById('cube-menu');
        const readButton = document.getElementById('read-button');

        readButton.addEventListener('click', () => {
            closeMenu();
            showBlogPost();
        });

        // Close menu when clicking outside both menu and renderer
        document.addEventListener('click', (event) => {
            if (!menu.contains(event.target) && event.target !== renderer.domElement) {
                closeMenu();
            }
        });
    }

    function showBlogPost() {
        const blogOverlay = document.getElementById('blog-overlay');
        const blogText = document.getElementById('blog-text');
        
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            // The content will be rendered by Jekyll
            blogOverlay.classList.add('visible');
        }
    }

    function destroyCube(id) {
        const data = pickingData[id];
        if (!data) return;

        // Find and remove the original cube from the merged geometry
        scene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                const colors = object.geometry.attributes.color;
                const indices = object.geometry.index.array;
                
                // Find the cube's vertices and hide them
                for (let i = 0; i < vertices.count; i += 24) {  // 24 vertices per cube
                    if (ids[i] === id) {
                        // Hide the vertices by scaling them to 0
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
                
                // Create fragments with parameters based on cube ID
                const destructionType = id % 4; // Use cube ID to determine destruction type
                createFragments(data.position, data.scale, destructionType);
            }
        });

        // Also hide in picking scene
        pickingScene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                
                for (let i = 0; i < vertices.count; i += 24) {
                    if (ids[i] === id) {
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
            }
        });

        // Mark this cube as destroyed
        pickingData[id].destroyed = true;
    }

    function createFragments(position, scale, destructionType = 0) {
        // Vary parameters based on destruction type
        const config = {
            0: { // Default
                fragmentCount: 8,
                fragmentSize: 4,
                spread: 2,
                gravity: gravity,
                upwardForce: 2
            },
            1: { // Fast fall, many pieces
                fragmentCount: 12,
                fragmentSize: 5,
                spread: 3,
                gravity: new THREE.Vector3(0, -0.025, 0),
                upwardForce: 1.5
            },
            2: { // Explosive
                fragmentCount: 6,
                fragmentSize: 3,
                spread: 4,
                gravity: new THREE.Vector3(0, -0.01, 0),
                upwardForce: 3
            },
            3: { // Implosive
                fragmentCount: 10,
                fragmentSize: 6,
                spread: 1,
                gravity: new THREE.Vector3(0, -0.02, 0),
                upwardForce: 1
            }
        }[destructionType];

        const fragmentSize = Math.min(scale.x, scale.y, scale.z) / config.fragmentSize;
        
        // Array of possible geometries for fragments
        const geometries = [
            () => new THREE.TetrahedronGeometry(fragmentSize * 0.8),
            () => new THREE.OctahedronGeometry(fragmentSize * 0.7),
            () => new THREE.BoxGeometry(fragmentSize, fragmentSize, fragmentSize),
            () => new THREE.DodecahedronGeometry(fragmentSize * 0.6),
            () => new THREE.IcosahedronGeometry(fragmentSize * 0.7)
        ];

        const fragmentMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            shininess: 0
        });

        // Create fragments with varying count
        for (let i = 0; i < config.fragmentCount; i++) {
            const randomGeometry = geometries[Math.floor(Math.random() * geometries.length)]();
            
            const angle = (i / config.fragmentCount) * Math.PI * 2;
            const radius = fragmentSize * config.spread;
            
            const offset = new THREE.Vector3(
                Math.cos(angle) * radius,
                Math.random() * radius,
                Math.sin(angle) * radius
            );

            const fragmentPos = position.clone().add(offset);
            
            // Adjust velocity based on config
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * config.spread,
                Math.random() * config.upwardForce,
                (Math.random() - 0.5) * config.spread
            );

            const rotation = new THREE.Vector3(
                Math.random() * 0.05,
                Math.random() * 0.05,
                Math.random() * 0.05
            );

            fragments.push(new Fragment(
                randomGeometry,
                fragmentMaterial,
                fragmentPos,
                velocity,
                rotation,
                config.gravity // Pass custom gravity to Fragment
            ));
        }
    }

    function init() {
        container = document.getElementById('container');

        // Adjust initial camera position to be closer
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 2000;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        scene.add(new THREE.AmbientLight(0xcccccc));

        const light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(0, 500, 2000);
        scene.add(light);

        const defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            vertexColors: false,
            shininess: 0
        });

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
            type: THREE.IntType,
            format: THREE.RGBAIntegerFormat,
            internalFormat: 'RGBA32I',
        });

        const pickingMaterial = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3,
            vertexShader: /* glsl */`
                attribute int id;
                flat varying int vid;
                void main() {
                    vid = id;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */`
                layout(location = 0) out int out_id;
                flat varying int vid;
                void main() {
                    out_id = vid;
                }
            `,
        });

        function applyId(geometry, id) {
            const position = geometry.attributes.position;
            const array = new Int16Array(position.count);
            array.fill(id);
            const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
            bufferAttribute.gpuType = THREE.IntType;
            geometry.setAttribute('id', bufferAttribute);
        }

        function applyVertexColors(geometry, color) {
            const position = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        const geometries = [];
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const defaultColor = new THREE.Color(0xcccccc);

        for (let i = 0; i < 5000; i++) {
            const geometry = new THREE.BoxGeometry();
            const position = new THREE.Vector3();
            
            if (i in cubeBlogMappings) {
                // Position blog cubes in a circle around the center
                const angle = (i / Object.keys(cubeBlogMappings).length) * Math.PI * 2;
                position.x = Math.cos(angle) * 800;
                position.y = Math.sin(angle) * 800;
                position.z = 500;
            } else {
                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;
            }

            const rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            const scale = new THREE.Vector3();
            if (i in cubeBlogMappings) {
                // Make blog cubes a consistent size
                scale.x = scale.y = scale.z = 200;
            } else {
                scale.x = Math.random() * 200 + 100;
                scale.y = Math.random() * 200 + 100;
                scale.z = Math.random() * 200 + 100;
            }

            quaternion.setFromEuler(rotation);
            matrix.compose(position, quaternion, scale);
            geometry.applyMatrix4(matrix);

            // Color special cubes according to their mapping
            if (i in cubeBlogMappings) {
                const blogMaterial = new THREE.MeshPhongMaterial({
                    color: cubeBlogMappings[i].color,
                    flatShading: true,
                    shininess: 30
                });
                applyVertexColors(geometry, new THREE.Color(cubeBlogMappings[i].color));
                applyId(geometry, i);
                
                // Add to both scenes
                const mainMesh = new THREE.Mesh(geometry, blogMaterial);
                const pickingMesh = new THREE.Mesh(geometry.clone(), pickingMaterial);
                
                scene.add(mainMesh);
                pickingScene.add(pickingMesh);
            } else {
                applyVertexColors(geometry, defaultColor);
                applyId(geometry, i);
                geometries.push(geometry);
            }
            
            pickingData[i] = {
                position: position,
                rotation: rotation,
                scale: scale
            };
        }

        const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
        pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));

        highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(),
            new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.FrontSide,
                wireframe: true,
                wireframeLinewidth: 2
            })
        );
        highlightBox.scale.multiplyScalar(1.2);
        highlightBox.visible = false;
        scene.add(highlightBox);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        // Add zoom constraints
        controls.minDistance = 1000;
        controls.maxDistance = 3500;

        // Add event listeners for user interaction
        controls.addEventListener('start', () => {
            stopAutoRotation();
        });

        // Add change event listener to close menu when camera moves
        controls.addEventListener('change', () => {
            closeMenu();
        });

        // Single event listener for pointer down
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('resize', onWindowResize);

        stats = new Stats();
        container.appendChild(stats.dom);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerDown(event) {
        event.preventDefault();
        stopAutoRotation();
        
        // Get pointer coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Perform picking
        pick();

        const currentTime = Date.now();
        const menu = document.getElementById('cube-menu');
        
        if (pickedId !== -1 && !pickingData[pickedId]?.destroyed) {
            if (pickedId === selectedCubeId && currentTime - lastInteractionTime < INTERACTION_TIMEOUT) {
                // Second click on the same cube - show menu at click position
                if (pickedId in cubeBlogMappings) {
                    const clickPosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    showCubeMenu(clickPosition);
                } else {
                    // For regular cubes, destroy them
                    destroyCube(pickedId);
                    closeMenu();
                }
            } else {
                // First click - select the cube
                if (menu.style.display === 'block') {
                    closeMenu();
                }
                selectedCubeId = pickedId;
                lastInteractionTime = currentTime;
                
                // Show highlight box
                const data = pickingData[pickedId];
                highlightBox.visible = true;
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                const highlightScale = data.scale.clone().multiplyScalar(1.1);
                highlightBox.scale.copy(highlightScale);
            }
        } else {
            // Clicked empty space or destroyed cube - deselect and hide menu
            if (!menu.contains(event.target)) {
                closeMenu();
            }
        }
    }

    function pick() {
        // render the picking scene off-screen
        const dpr = window.devicePixelRatio;
        
        // Calculate pixel coordinates
        const x = Math.floor((pointer.x + 1) * renderer.domElement.width / 2);
        const y = Math.floor((-pointer.y + 1) * renderer.domElement.height / 2);

        // Set camera view to look at just that pixel
        camera.setViewOffset(
            renderer.domElement.width,
            renderer.domElement.height,
            x,
            y,
            1,
            1
        );

        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickingScene, camera);

        // read the pixel
        const pixelBuffer = new Int32Array(4);
        renderer.readRenderTargetPixels(pickingTexture, 0, 0, 1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        // restore the camera
        camera.clearViewOffset();

        const id = pixelBuffer[0];
        pickedId = id;
    }

    function animate(time) {
        const deltaTime = lastTime ? (time - lastTime) : 0;
        lastTime = time;

        // Check for inactivity
        checkInactivity();

        // Apply auto-rotation if active
        if (autoRotating) {
            scene.rotation.y += autoRotationSpeed;
            pickingScene.rotation.y += autoRotationSpeed;
        }

        // Update fragments
        for (let i = fragments.length - 1; i >= 0; i--) {
            if (fragments[i].update()) {
                fragments.splice(i, 1);
            }
        }

        render();
        stats.update();
    }

    function render() {
        controls.update();
        
        if (highlightBox.visible && pickedId !== -1) {
            const data = pickingData[pickedId];
            if (data) {
                highlightBox.rotation.copy(data.rotation);
            }
        }
        
        renderer.render(scene, camera);
    }

    function showCubeMenu(screenPosition) {
        const menu = document.getElementById('cube-menu');
        const menuTitle = menu.querySelector('.menu-title');
        const menuBrief = menu.querySelector('.menu-brief');
        const menuAuthor = menu.querySelector('.menu-metadata .author');
        const menuDate = menu.querySelector('.menu-metadata .date');
        
        // Set the content from the blog mapping
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            menuTitle.textContent = post.title;
            menuBrief.textContent = post.brief;
            menuAuthor.textContent = post.author;
            menuDate.textContent = post.date;
        }
        
        // Make menu visible to get dimensions
        menu.style.display = 'block';
        menu.style.opacity = '0';
        
        // Get dimensions and viewport info
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const isMobile = viewportWidth <= 768;
        const menuRect = menu.getBoundingClientRect();
        
        // Define safe margins and zones
        const TOP_MARGIN = 80;
        const EDGE_MARGIN = 20;
        const SPACING = 20;
        const CENTER_ZONE_SIZE = 0.4; // 40% of viewport height for center zone
        const CENTER_OFFSET = 100; // How much to move up in center zone
        
        let top;
        
        if (isMobile) {
            // On mobile, position relative to click but ensure visibility
            top = screenPosition.y;
            
            // Check if in vertical center zone
            const centerZoneTop = viewportHeight * (0.5 - CENTER_ZONE_SIZE / 2);
            const centerZoneBottom = viewportHeight * (0.5 + CENTER_ZONE_SIZE / 2);
            const isInCenterZone = screenPosition.y >= centerZoneTop && screenPosition.y <= centerZoneBottom;
            
            if (isInCenterZone) {
                // If in center zone, position menu higher
                top = Math.max(TOP_MARGIN, screenPosition.y - menuRect.height - CENTER_OFFSET);
            } else if (top + menuRect.height > viewportHeight - EDGE_MARGIN) {
                // If would go below viewport, show above click point
                top = Math.max(TOP_MARGIN, screenPosition.y - menuRect.height - SPACING);
            }
            
            // If still too low, force it to start from TOP_MARGIN
            if (top + menuRect.height > viewportHeight - EDGE_MARGIN) {
                top = TOP_MARGIN;
            }
            
            // Apply mobile positioning
            menu.style.top = `${top}px`;
            menu.style.transform = 'none';
            menu.style.left = '20px';
            menu.style.right = '20px';
            menu.style.width = 'auto';
        } else {
            // Desktop positioning
            let left;
            
            // Horizontal positioning
            const isInLeftHalf = screenPosition.x < viewportWidth / 2;
            if (isInLeftHalf) {
                left = screenPosition.x + SPACING;
            } else {
                left = screenPosition.x - menuRect.width - SPACING;
            }
            
            // Check if in vertical center zone
            const centerZoneTop = viewportHeight * (0.5 - CENTER_ZONE_SIZE / 2);
            const centerZoneBottom = viewportHeight * (0.5 + CENTER_ZONE_SIZE / 2);
            const isInCenterZone = screenPosition.y >= centerZoneTop && screenPosition.y <= centerZoneBottom;
            
            // Vertical positioning for desktop
            if (isInCenterZone) {
                // If in center zone, position menu higher
                top = Math.max(TOP_MARGIN, screenPosition.y - menuRect.height - CENTER_OFFSET);
            } else {
                top = screenPosition.y;
                if (top + menuRect.height > viewportHeight - EDGE_MARGIN) {
                    top = screenPosition.y - menuRect.height - SPACING;
                }
            }
            
            // Ensure menu stays within viewport bounds
            if (left < EDGE_MARGIN) {
                left = EDGE_MARGIN;
            } else if (left + menuRect.width > viewportWidth - EDGE_MARGIN) {
                left = viewportWidth - menuRect.width - EDGE_MARGIN;
            }
            
            if (top < TOP_MARGIN) {
                top = TOP_MARGIN;
            }
            
            // Apply desktop positioning
            menu.style.left = `${left}px`;
            menu.style.right = 'auto';
            menu.style.width = '';
            menu.style.top = `${top}px`;
        }
        
        // Make menu visible
        menu.style.opacity = '1';
    }
</script> 
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 New Cubes Blog. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> 