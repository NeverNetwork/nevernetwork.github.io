<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>New Cubes Blog</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>New Cubes Blog | A blog featuring interactive 3D visualizations</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="New Cubes Blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="A blog featuring interactive 3D visualizations" />
<meta property="og:description" content="A blog featuring interactive 3D visualizations" />
<link rel="canonical" href="http://localhost:4000/" />
<meta property="og:url" content="http://localhost:4000/" />
<meta property="og:site_name" content="New Cubes Blog" />
<meta property="og:type" content="website" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="New Cubes Blog" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"WebSite","description":"A blog featuring interactive 3D visualizations","headline":"New Cubes Blog","name":"New Cubes Blog","url":"http://localhost:4000/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1 class="site-title"><a href="/">New Cubes Blog</a></h1>
            <nav class="site-nav">
                <a href="/">Home</a>
                <a href="/blog">Blog</a>
            </nav>
        </div>
    </header>

    <main class="site-content">
        <div class="container">
            <div id="container"></div>
<div id="blog-overlay" class="hidden">
    <div class="blog-content">
        <div class="close-button">&times;</div>
        <div id="blog-text"><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome to the Interactive Cubes Blog - New Cubes Blog</title>
    <link rel="stylesheet" href="/assets/css/main.css">
    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Welcome to the Interactive Cubes Blog | New Cubes Blog</title>
<meta name="generator" content="Jekyll v4.3.4" />
<meta property="og:title" content="Welcome to the Interactive Cubes Blog" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Welcome to the Interactive Cubes Blog!" />
<meta property="og:description" content="Welcome to the Interactive Cubes Blog!" />
<link rel="canonical" href="http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/" />
<meta property="og:url" content="http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/" />
<meta property="og:site_name" content="New Cubes Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-04-09T00:00:00+03:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Welcome to the Interactive Cubes Blog" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-09T00:00:00+03:00","datePublished":"2024-04-09T00:00:00+03:00","description":"Welcome to the Interactive Cubes Blog!","headline":"Welcome to the Interactive Cubes Blog","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/"},"url":"http://localhost:4000/blog/2024/04/09/welcome-to-new-cubes-blog/"}</script>
<!-- End Jekyll SEO tag -->

</head>
<body>
    <header class="site-header">
        <div class="container">
            <h1 class="site-title"><a href="/">New Cubes Blog</a></h1>
            <nav class="site-nav">
                <a href="/">Home</a>
                <a href="/blog">Blog</a>
            </nav>
        </div>
    </header>

    <main class="site-content">
        <div class="container">
            <article class="post">
  <header class="post-header">
    <h1 class="post-title">Welcome to the Interactive Cubes Blog</h1>
    <p class="post-meta">
      <time datetime="2024-04-09T00:00:00+03:00">
        April 9, 2024
      </time>
    </p>
  </header>

  <div class="post-content">
    <h1 id="welcome-to-the-interactive-cubes-blog">Welcome to the Interactive Cubes Blog!</h1>

<p>You’ve found the special red cube! This is your gateway to exploring our blog about Three.js, WebGL, and creative coding.</p>

<h2 id="about-this-project">About This Project</h2>

<p>This blog combines interactive 3D visualizations with written content. The main page features thousands of floating cubes, with one special red cube that leads you here. This interaction demonstrates the power of Three.js for creating engaging web experiences.</p>

<h2 id="how-it-works">How It Works</h2>

<p>The cube visualization you just interacted with uses several advanced Three.js features:</p>

<ol>
  <li><strong>GPU Picking</strong> - To detect which cube you’re hovering over</li>
  <li><strong>Custom Shaders</strong> - For efficient rendering of thousands of cubes</li>
  <li><strong>TrackballControls</strong> - For smooth camera movement</li>
  <li><strong>Merged Geometries</strong> - For optimal performance</li>
</ol>

<h2 id="stay-connected">Stay Connected</h2>

<p>Keep exploring the cubes and check back for more posts about:</p>
<ul>
  <li>Three.js tutorials</li>
  <li>WebGL optimization tips</li>
  <li>Creative coding techniques</li>
  <li>Interactive web experiences</li>
</ul>

<p>Feel free to click around and discover more about 3D graphics on the web!</p>

  </div>
</article>

<div class="post-navigation">
  
  
</div> 
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 New Cubes Blog. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> </div>
    </div>
</div>

<style>
#container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#blog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#blog-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.blog-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.close-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    font-size: 1.5rem;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: #f0f0f0;
}

.close-button:hover {
    background: #e0e0e0;
}
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

    let container, stats;
    let camera, controls, scene, renderer;
    let pickingTexture, pickingScene;
    let highlightBox;
    let pickedId = -1;
    const fragments = [];
    const gravity = new THREE.Vector3(0, -0.015, 0);
    let lastTime = 0;
    const pickingData = [];
    const pointer = new THREE.Vector2();
    const offset = new THREE.Vector3(10, 10, 10);
    const clearColor = new THREE.Color();

    class Fragment {
        constructor(geometry, material, position, velocity, rotation, customGravity = gravity) {
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);
            this.velocity = velocity;
            this.rotation = rotation;
            this.gravity = customGravity;
            scene.add(this.mesh);
        }

        update() {
            this.velocity.add(this.gravity);
            this.mesh.position.add(this.velocity);
            this.mesh.rotation.x += this.rotation.x;
            this.mesh.rotation.y += this.rotation.y;
            this.mesh.rotation.z += this.rotation.z;

            // Remove if fallen below certain point
            if (this.mesh.position.y < -2000) {
                scene.remove(this.mesh);
                return true;
            }
            return false;
        }
    }

    // Define blog post mappings
    const cubeBlogMappings = {
        42: {
            title: "Welcome to the Interactive Cubes Blog",
            url: "/blog/2024/04/09/welcome-to-new-cubes-blog/",
            color: 0xff0000
        }
        // Add more mappings here for other cubes and posts
    };

    init();
    setupBlogOverlay();

    function setupBlogOverlay() {
        const overlay = document.getElementById('blog-overlay');
        const closeButton = document.querySelector('.close-button');
        
        closeButton.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });

        // Add click event listener to the renderer
        renderer.domElement.addEventListener('click', () => {
            if (pickedId in cubeBlogMappings) {
                showBlogPost();
            } else if (pickedId !== -1) {
                destroyCube(pickedId);
            }
        });
    }

    function showBlogPost() {
        const blogOverlay = document.getElementById('blog-overlay');
        const blogText = document.getElementById('blog-text');
        
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            // The content will be rendered by Jekyll
            blogOverlay.classList.add('visible');
        }
    }

    function destroyCube(id) {
        const data = pickingData[id];
        if (!data) return;

        // Find and remove the original cube from the merged geometry
        scene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                const colors = object.geometry.attributes.color;
                const indices = object.geometry.index.array;
                
                // Find the cube's vertices and hide them
                for (let i = 0; i < vertices.count; i += 24) {  // 24 vertices per cube
                    if (ids[i] === id) {
                        // Hide the vertices by scaling them to 0
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
                
                // Create fragments with parameters based on cube ID
                const destructionType = id % 4; // Use cube ID to determine destruction type
                createFragments(data.position, data.scale, destructionType);
            }
        });

        // Also hide in picking scene
        pickingScene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                
                for (let i = 0; i < vertices.count; i += 24) {
                    if (ids[i] === id) {
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
            }
        });

        // Mark this cube as destroyed
        pickingData[id].destroyed = true;
    }

    function createFragments(position, scale, destructionType = 0) {
        // Vary parameters based on destruction type
        const config = {
            0: { // Default
                fragmentCount: 8,
                fragmentSize: 4,
                spread: 2,
                gravity: gravity,
                upwardForce: 2
            },
            1: { // Fast fall, many pieces
                fragmentCount: 12,
                fragmentSize: 5,
                spread: 3,
                gravity: new THREE.Vector3(0, -0.025, 0),
                upwardForce: 1.5
            },
            2: { // Explosive
                fragmentCount: 6,
                fragmentSize: 3,
                spread: 4,
                gravity: new THREE.Vector3(0, -0.01, 0),
                upwardForce: 3
            },
            3: { // Implosive
                fragmentCount: 10,
                fragmentSize: 6,
                spread: 1,
                gravity: new THREE.Vector3(0, -0.02, 0),
                upwardForce: 1
            }
        }[destructionType];

        const fragmentSize = Math.min(scale.x, scale.y, scale.z) / config.fragmentSize;
        
        // Array of possible geometries for fragments
        const geometries = [
            () => new THREE.TetrahedronGeometry(fragmentSize * 0.8),
            () => new THREE.OctahedronGeometry(fragmentSize * 0.7),
            () => new THREE.BoxGeometry(fragmentSize, fragmentSize, fragmentSize),
            () => new THREE.DodecahedronGeometry(fragmentSize * 0.6),
            () => new THREE.IcosahedronGeometry(fragmentSize * 0.7)
        ];

        const fragmentMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            shininess: 0
        });

        // Create fragments with varying count
        for (let i = 0; i < config.fragmentCount; i++) {
            const randomGeometry = geometries[Math.floor(Math.random() * geometries.length)]();
            
            const angle = (i / config.fragmentCount) * Math.PI * 2;
            const radius = fragmentSize * config.spread;
            
            const offset = new THREE.Vector3(
                Math.cos(angle) * radius,
                Math.random() * radius,
                Math.sin(angle) * radius
            );

            const fragmentPos = position.clone().add(offset);
            
            // Adjust velocity based on config
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * config.spread,
                Math.random() * config.upwardForce,
                (Math.random() - 0.5) * config.spread
            );

            const rotation = new THREE.Vector3(
                Math.random() * 0.05,
                Math.random() * 0.05,
                Math.random() * 0.05
            );

            fragments.push(new Fragment(
                randomGeometry,
                fragmentMaterial,
                fragmentPos,
                velocity,
                rotation,
                config.gravity // Pass custom gravity to Fragment
            ));
        }
    }

    function init() {
        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 1000;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        scene.add(new THREE.AmbientLight(0xcccccc));

        const light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(0, 500, 2000);
        scene.add(light);

        const defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            vertexColors: false,
            shininess: 0
        });

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
            type: THREE.IntType,
            format: THREE.RGBAIntegerFormat,
            internalFormat: 'RGBA32I',
        });

        const pickingMaterial = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3,
            vertexShader: /* glsl */`
                attribute int id;
                flat varying int vid;
                void main() {
                    vid = id;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */`
                layout(location = 0) out int out_id;
                flat varying int vid;
                void main() {
                    out_id = vid;
                }
            `,
        });

        function applyId(geometry, id) {
            const position = geometry.attributes.position;
            const array = new Int16Array(position.count);
            array.fill(id);
            const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
            bufferAttribute.gpuType = THREE.IntType;
            geometry.setAttribute('id', bufferAttribute);
        }

        function applyVertexColors(geometry, color) {
            const position = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        const geometries = [];
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const defaultColor = new THREE.Color(0xcccccc);

        for (let i = 0; i < 5000; i++) {
            const geometry = new THREE.BoxGeometry();
            const position = new THREE.Vector3();
            
            if (i in cubeBlogMappings) {
                // Position blog cubes in a circle around the center
                const angle = (i / Object.keys(cubeBlogMappings).length) * Math.PI * 2;
                position.x = Math.cos(angle) * 800;
                position.y = Math.sin(angle) * 800;
                position.z = 500;
            } else {
                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;
            }

            const rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            const scale = new THREE.Vector3();
            if (i in cubeBlogMappings) {
                // Make blog cubes a consistent size
                scale.x = scale.y = scale.z = 200;
            } else {
                scale.x = Math.random() * 200 + 100;
                scale.y = Math.random() * 200 + 100;
                scale.z = Math.random() * 200 + 100;
            }

            quaternion.setFromEuler(rotation);
            matrix.compose(position, quaternion, scale);
            geometry.applyMatrix4(matrix);

            // Color special cubes according to their mapping
            if (i in cubeBlogMappings) {
                const blogMaterial = new THREE.MeshPhongMaterial({
                    color: cubeBlogMappings[i].color,
                    flatShading: true,
                    shininess: 30
                });
                applyVertexColors(geometry, new THREE.Color(cubeBlogMappings[i].color));
                applyId(geometry, i);
                
                // Add to both scenes
                const mainMesh = new THREE.Mesh(geometry, blogMaterial);
                const pickingMesh = new THREE.Mesh(geometry.clone(), pickingMaterial);
                
                scene.add(mainMesh);
                pickingScene.add(pickingMesh);
            } else {
                applyVertexColors(geometry, defaultColor);
                applyId(geometry, i);
                geometries.push(geometry);
            }
            
            pickingData[i] = {
                position: position,
                rotation: rotation,
                scale: scale
            };
        }

        const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
        pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));

        highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(),
            new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.FrontSide,
                wireframe: true,
                wireframeLinewidth: 2
            })
        );
        highlightBox.scale.multiplyScalar(1.2);
        highlightBox.visible = false;
        scene.add(highlightBox);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        stats = new Stats();
        container.appendChild(stats.dom);

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerMove(event) {
        pointer.x = event.clientX;
        pointer.y = event.clientY;
        pick();
    }

    function pick() {
        // render the picking scene off-screen
        const dpr = window.devicePixelRatio;
        camera.setViewOffset(
            renderer.domElement.width, renderer.domElement.height,
            Math.floor(pointer.x * dpr), Math.floor(pointer.y * dpr),
            1, 1
        );

        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickingScene, camera);

        // read the pixel
        const pixelBuffer = new Int32Array(4);
        renderer.readRenderTargetPixels(pickingTexture, 0, 0, 1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        // restore the camera
        camera.clearViewOffset();

        const id = pixelBuffer[0];
        pickedId = id;
        
        if (id !== -1 && id !== undefined && id !== null && !pickingData[id]?.destroyed) {
            const data = pickingData[id];
            if (data) {
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                highlightBox.scale.copy(data.scale).multiplyScalar(1.2);
                highlightBox.visible = true;
            }
        } else {
            highlightBox.visible = false;
        }
    }

    function animate(time) {
        const deltaTime = lastTime ? (time - lastTime) : 0;
        lastTime = time;

        // Update fragments
        for (let i = fragments.length - 1; i >= 0; i--) {
            if (fragments[i].update()) {
                fragments.splice(i, 1);
            }
        }

        render();
        stats.update();
    }

    function render() {
        controls.update();
        
        if (highlightBox.visible && pickedId !== -1) {
            const data = pickingData[pickedId];
            if (data) {
                highlightBox.rotation.copy(data.rotation);
            }
        }
        
        renderer.render(scene, camera);
    }
</script> 
        </div>
    </main>

    <footer class="site-footer">
        <div class="container">
            <p>&copy; 2025 New Cubes Blog. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> 