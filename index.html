---
layout: default
---

<div id="container"></div>
<div id="blog-overlay" class="hidden">
    <div class="blog-content">
        <div class="close-button">&times;</div>
        <div id="blog-text">{{ site.posts | first }}</div>
    </div>
</div>

<style>
#container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#blog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#blog-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.blog-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.close-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    font-size: 1.5rem;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: #f0f0f0;
}

.close-button:hover {
    background: #e0e0e0;
}
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

    let container, stats;
    let camera, controls, scene, renderer;
    let pickingTexture, pickingScene;
    let highlightBox;
    let pickedId = -1;
    const SPECIAL_CUBE_ID = 42; // We'll make cube #42 special

    const pickingData = [];
    const pointer = new THREE.Vector2();
    const offset = new THREE.Vector3(10, 10, 10);
    const clearColor = new THREE.Color();

    // Define blog post mappings
    const cubeBlogMappings = {
        42: {
            title: "Welcome to the Interactive Cubes Blog",
            url: "{% post_url 2024-04-09-welcome-to-new-cubes-blog %}",
            color: 0xff0000
        }
        // Add more mappings here for other cubes and posts
    };

    init();
    setupBlogOverlay();

    function setupBlogOverlay() {
        const overlay = document.getElementById('blog-overlay');
        const closeButton = document.querySelector('.close-button');
        
        closeButton.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });

        // Add click event listener to the renderer
        renderer.domElement.addEventListener('click', () => {
            if (pickedId === SPECIAL_CUBE_ID) {
                showBlogPost();
            }
        });
    }

    function showBlogPost() {
        const blogOverlay = document.getElementById('blog-overlay');
        const blogText = document.getElementById('blog-text');
        
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            // The content will be rendered by Jekyll
            blogOverlay.classList.add('visible');
        }
    }

    function init() {
        container = document.getElementById('container');

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 1000;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        scene.add(new THREE.AmbientLight(0xcccccc));

        const light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(0, 500, 2000);
        scene.add(light);

        const defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            vertexColors: false,
            shininess: 0
        });

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
            type: THREE.IntType,
            format: THREE.RGBAIntegerFormat,
            internalFormat: 'RGBA32I',
        });

        const pickingMaterial = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3,
            vertexShader: /* glsl */`
                attribute int id;
                flat varying int vid;
                void main() {
                    vid = id;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */`
                layout(location = 0) out int out_id;
                flat varying int vid;
                void main() {
                    out_id = vid;
                }
            `,
        });

        function applyId(geometry, id) {
            const position = geometry.attributes.position;
            const array = new Int16Array(position.count);
            array.fill(id);
            const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
            bufferAttribute.gpuType = THREE.IntType;
            geometry.setAttribute('id', bufferAttribute);
        }

        function applyVertexColors(geometry, color) {
            const position = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        const geometries = [];
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const defaultColor = new THREE.Color(0xcccccc);

        for (let i = 0; i < 5000; i++) {
            const geometry = new THREE.BoxGeometry();
            const position = new THREE.Vector3();
            
            if (i in cubeBlogMappings) {
                // Position blog cubes in a circle around the center
                const angle = (i / Object.keys(cubeBlogMappings).length) * Math.PI * 2;
                position.x = Math.cos(angle) * 800;
                position.y = Math.sin(angle) * 800;
                position.z = 500;
            } else {
                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;
            }

            const rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            const scale = new THREE.Vector3();
            if (i in cubeBlogMappings) {
                // Make blog cubes a consistent size
                scale.x = scale.y = scale.z = 200;
            } else {
                scale.x = Math.random() * 200 + 100;
                scale.y = Math.random() * 200 + 100;
                scale.z = Math.random() * 200 + 100;
            }

            quaternion.setFromEuler(rotation);
            matrix.compose(position, quaternion, scale);
            geometry.applyMatrix4(matrix);

            // Color special cubes according to their mapping
            if (i in cubeBlogMappings) {
                const blogMaterial = new THREE.MeshPhongMaterial({
                    color: cubeBlogMappings[i].color,
                    flatShading: true,
                    shininess: 30
                });
                applyVertexColors(geometry, new THREE.Color(cubeBlogMappings[i].color));
                applyId(geometry, i);
                
                // Add to both scenes
                const mainMesh = new THREE.Mesh(geometry, blogMaterial);
                const pickingMesh = new THREE.Mesh(geometry.clone(), pickingMaterial);
                
                scene.add(mainMesh);
                pickingScene.add(pickingMesh);
            } else {
                applyVertexColors(geometry, defaultColor);
                applyId(geometry, i);
                geometries.push(geometry);
            }
            
            pickingData[i] = {
                position: position,
                rotation: rotation,
                scale: scale
            };
        }

        const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
        pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));

        highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(),
            new THREE.MeshBasicMaterial({ 
                color: 0xffff00,
                side: THREE.FrontSide,
                wireframe: true,
                wireframeLinewidth: 2
            })
        );
        highlightBox.scale.multiplyScalar(1.2);
        highlightBox.visible = false;
        scene.add(highlightBox);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        stats = new Stats();
        container.appendChild(stats.dom);

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerMove(event) {
        pointer.x = event.clientX;
        pointer.y = event.clientY;
        pick();
    }

    function pick() {
        // render the picking scene off-screen
        const dpr = window.devicePixelRatio;
        camera.setViewOffset(
            renderer.domElement.width, renderer.domElement.height,
            Math.floor(pointer.x * dpr), Math.floor(pointer.y * dpr),
            1, 1
        );

        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickingScene, camera);

        // read the pixel
        const pixelBuffer = new Int32Array(4);
        renderer.readRenderTargetPixels(pickingTexture, 0, 0, 1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        // restore the camera
        camera.clearViewOffset();

        const id = pixelBuffer[0];
        pickedId = id;
        
        if (id !== -1 && id !== undefined && id !== null) {
            const data = pickingData[id];
            if (data) {
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                highlightBox.scale.copy(data.scale).multiplyScalar(1.2);
                highlightBox.visible = true;
            }
        } else {
            highlightBox.visible = false;
        }
    }

    function animate() {
        render();
        stats.update();
    }

    function render() {
        controls.update();
        
        if (highlightBox.visible && pickedId !== -1) {
            const data = pickingData[pickedId];
            if (data) {
                highlightBox.rotation.copy(data.rotation);
            }
        }
        
        renderer.render(scene, camera);
    }
</script> 