---
layout: default
---

<div id="container"></div>
<div id="blog-overlay" class="hidden">
    <div class="blog-content">
        <div class="close-button">&times;</div>
        <div id="blog-text">{{ site.posts | first }}</div>
    </div>
</div>

<div id="cube-menu">
    <div class="menu-title"></div>
    <div class="menu-brief"></div>
    <div class="menu-metadata">
        <span class="author"></span>
        <span class="date"></span>
    </div>
    <button id="read-button">Read</button>
</div>

<style>
#container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#blog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#blog-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.blog-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.close-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    font-size: 1.5rem;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: #f0f0f0;
}

.close-button:hover {
    background: #e0e0e0;
}

#cube-menu {
    display: none;
    position: fixed;
    background: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 10px;
    z-index: 1000;
    min-width: 250px;
    max-width: 350px;
}

#cube-menu .menu-title {
    color: white;
    font-size: 18px;
    margin-bottom: 8px;
    font-weight: 600;
    line-height: 1.4;
}

#cube-menu .menu-brief {
    color: rgba(255, 255, 255, 0.9);
    font-size: 14px;
    margin-bottom: 15px;
    line-height: 1.5;
}

#cube-menu .menu-metadata {
    color: rgba(255, 255, 255, 0.7);
    font-size: 13px;
    margin-bottom: 15px;
    line-height: 1.4;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    padding-top: 12px;
}

#cube-menu .menu-metadata span {
    display: block;
}

#cube-menu button {
    display: block;
    width: 100%;
    padding: 15px;
    margin: 0 auto;
    border: none;
    border-radius: 5px;
    background: #ff3333;
    color: white;
    font-size: 18px;
    cursor: pointer;
    transition: background 0.3s;
    text-align: center;
}

#cube-menu button:hover {
    background: #cc0000;
}
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

    let container, stats;
    let camera, controls, scene, renderer;
    let pickingTexture, pickingScene;
    let highlightBox;
    let pickedId = -1;
    let selectedCubeId = -1;  // Track the currently selected cube
    let lastInteractionTime = 0;
    const INTERACTION_TIMEOUT = 500; // Time window for second interaction (ms)
    const fragments = [];
    const gravity = new THREE.Vector3(0, -0.015, 0);
    let lastTime = 0;
    const pickingData = [];
    const pointer = new THREE.Vector2();
    const offset = new THREE.Vector3(10, 10, 10);
    const clearColor = new THREE.Color();
    
    // Auto-rotation variables
    let autoRotating = true;
    const INACTIVITY_TIMEOUT = 10000; // 10 seconds
    const autoRotationSpeed = 0.0002; // Slow rotation speed
    
    function startAutoRotation() {
        autoRotating = true;
        // Close menu when auto-rotation starts
        closeMenu();
    }
    
    function stopAutoRotation() {
        autoRotating = false;
        lastInteractionTime = Date.now();
    }

    function closeMenu() {
        const menu = document.getElementById('cube-menu');
        menu.style.display = 'none';
        selectedCubeId = -1;
        highlightBox.visible = false;
    }

    function checkInactivity() {
        if (!autoRotating && Date.now() - lastInteractionTime > INACTIVITY_TIMEOUT) {
            startAutoRotation();
        }
    }

    class Fragment {
        constructor(geometry, material, position, velocity, rotation, customGravity = gravity) {
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);
            this.velocity = velocity;
            this.rotation = rotation;
            this.gravity = customGravity;
            scene.add(this.mesh);
        }

        update() {
            this.velocity.add(this.gravity);
            this.mesh.position.add(this.velocity);
            this.mesh.rotation.x += this.rotation.x;
            this.mesh.rotation.y += this.rotation.y;
            this.mesh.rotation.z += this.rotation.z;

            // Remove if fallen below certain point
            if (this.mesh.position.y < -2000) {
                scene.remove(this.mesh);
                return true;
            }
            return false;
        }
    }

    // Define blog post mappings
    const cubeBlogMappings = {
        42: {
            title: {{ site.posts.first.title | jsonify }},
            author: {{ site.posts.first.author | jsonify }},
            date: "{{ site.posts.first.date | date: '%B %-d, %Y' }}",
            brief: {{ site.posts.first.brief | jsonify }},
            url: "{% post_url 2024-04-09-welcome-to-new-cubes-blog %}",
            color: 0xff0000
        }
        // Add more mappings here for other cubes and posts
    };

    init();
    setupOverlays();

    function setupOverlays() {
        setupBlogOverlay();
        setupCubeMenu();
    }

    function setupBlogOverlay() {
        const overlay = document.getElementById('blog-overlay');
        const closeButton = document.querySelector('.close-button');
        
        closeButton.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });
    }

    function setupCubeMenu() {
        const menu = document.getElementById('cube-menu');
        const readButton = document.getElementById('read-button');

        readButton.addEventListener('click', () => {
            closeMenu();
            showBlogPost();
        });

        // Close menu when clicking outside both menu and renderer
        document.addEventListener('click', (event) => {
            if (!menu.contains(event.target) && event.target !== renderer.domElement) {
                closeMenu();
            }
        });
    }

    function showBlogPost() {
        const blogOverlay = document.getElementById('blog-overlay');
        const blogText = document.getElementById('blog-text');
        
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            // The content will be rendered by Jekyll
            blogOverlay.classList.add('visible');
        }
    }

    function destroyCube(id) {
        const data = pickingData[id];
        if (!data) return;

        // Find and remove the original cube from the merged geometry
        scene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                const colors = object.geometry.attributes.color;
                const indices = object.geometry.index.array;
                
                // Find the cube's vertices and hide them
                for (let i = 0; i < vertices.count; i += 24) {  // 24 vertices per cube
                    if (ids[i] === id) {
                        // Hide the vertices by scaling them to 0
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
                
                // Create fragments with parameters based on cube ID
                const destructionType = id % 4; // Use cube ID to determine destruction type
                createFragments(data.position, data.scale, destructionType);
            }
        });

        // Also hide in picking scene
        pickingScene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                
                for (let i = 0; i < vertices.count; i += 24) {
                    if (ids[i] === id) {
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
            }
        });

        // Mark this cube as destroyed
        pickingData[id].destroyed = true;
    }

    function createFragments(position, scale, destructionType = 0) {
        // Vary parameters based on destruction type
        const config = {
            0: { // Default
                fragmentCount: 8,
                fragmentSize: 4,
                spread: 2,
                gravity: gravity,
                upwardForce: 2
            },
            1: { // Fast fall, many pieces
                fragmentCount: 12,
                fragmentSize: 5,
                spread: 3,
                gravity: new THREE.Vector3(0, -0.025, 0),
                upwardForce: 1.5
            },
            2: { // Explosive
                fragmentCount: 6,
                fragmentSize: 3,
                spread: 4,
                gravity: new THREE.Vector3(0, -0.01, 0),
                upwardForce: 3
            },
            3: { // Implosive
                fragmentCount: 10,
                fragmentSize: 6,
                spread: 1,
                gravity: new THREE.Vector3(0, -0.02, 0),
                upwardForce: 1
            }
        }[destructionType];

        const fragmentSize = Math.min(scale.x, scale.y, scale.z) / config.fragmentSize;
        
        // Array of possible geometries for fragments
        const geometries = [
            () => new THREE.TetrahedronGeometry(fragmentSize * 0.8),
            () => new THREE.OctahedronGeometry(fragmentSize * 0.7),
            () => new THREE.BoxGeometry(fragmentSize, fragmentSize, fragmentSize),
            () => new THREE.DodecahedronGeometry(fragmentSize * 0.6),
            () => new THREE.IcosahedronGeometry(fragmentSize * 0.7)
        ];

        const fragmentMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            shininess: 0
        });

        // Create fragments with varying count
        for (let i = 0; i < config.fragmentCount; i++) {
            const randomGeometry = geometries[Math.floor(Math.random() * geometries.length)]();
            
            const angle = (i / config.fragmentCount) * Math.PI * 2;
            const radius = fragmentSize * config.spread;
            
            const offset = new THREE.Vector3(
                Math.cos(angle) * radius,
                Math.random() * radius,
                Math.sin(angle) * radius
            );

            const fragmentPos = position.clone().add(offset);
            
            // Adjust velocity based on config
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * config.spread,
                Math.random() * config.upwardForce,
                (Math.random() - 0.5) * config.spread
            );

            const rotation = new THREE.Vector3(
                Math.random() * 0.05,
                Math.random() * 0.05,
                Math.random() * 0.05
            );

            fragments.push(new Fragment(
                randomGeometry,
                fragmentMaterial,
                fragmentPos,
                velocity,
                rotation,
                config.gravity // Pass custom gravity to Fragment
            ));
        }
    }

    function init() {
        container = document.getElementById('container');

        // Adjust initial camera position to be closer
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 2000;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        scene.add(new THREE.AmbientLight(0xcccccc));

        const light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(0, 500, 2000);
        scene.add(light);

        const defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            vertexColors: false,
            shininess: 0
        });

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
            type: THREE.IntType,
            format: THREE.RGBAIntegerFormat,
            internalFormat: 'RGBA32I',
        });

        const pickingMaterial = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3,
            vertexShader: /* glsl */`
                attribute int id;
                flat varying int vid;
                void main() {
                    vid = id;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */`
                layout(location = 0) out int out_id;
                flat varying int vid;
                void main() {
                    out_id = vid;
                }
            `,
        });

        function applyId(geometry, id) {
            const position = geometry.attributes.position;
            const array = new Int16Array(position.count);
            array.fill(id);
            const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
            bufferAttribute.gpuType = THREE.IntType;
            geometry.setAttribute('id', bufferAttribute);
        }

        function applyVertexColors(geometry, color) {
            const position = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        const geometries = [];
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const defaultColor = new THREE.Color(0xcccccc);

        for (let i = 0; i < 5000; i++) {
            const geometry = new THREE.BoxGeometry();
            const position = new THREE.Vector3();
            
            if (i in cubeBlogMappings) {
                // Position blog cubes in a circle around the center
                const angle = (i / Object.keys(cubeBlogMappings).length) * Math.PI * 2;
                position.x = Math.cos(angle) * 800;
                position.y = Math.sin(angle) * 800;
                position.z = 500;
            } else {
                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;
            }

            const rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            const scale = new THREE.Vector3();
            if (i in cubeBlogMappings) {
                // Make blog cubes a consistent size
                scale.x = scale.y = scale.z = 200;
            } else {
                scale.x = Math.random() * 200 + 100;
                scale.y = Math.random() * 200 + 100;
                scale.z = Math.random() * 200 + 100;
            }

            quaternion.setFromEuler(rotation);
            matrix.compose(position, quaternion, scale);
            geometry.applyMatrix4(matrix);

            // Color special cubes according to their mapping
            if (i in cubeBlogMappings) {
                const blogMaterial = new THREE.MeshPhongMaterial({
                    color: cubeBlogMappings[i].color,
                    flatShading: true,
                    shininess: 30
                });
                applyVertexColors(geometry, new THREE.Color(cubeBlogMappings[i].color));
                applyId(geometry, i);
                
                // Add to both scenes
                const mainMesh = new THREE.Mesh(geometry, blogMaterial);
                const pickingMesh = new THREE.Mesh(geometry.clone(), pickingMaterial);
                
                scene.add(mainMesh);
                pickingScene.add(pickingMesh);
            } else {
                applyVertexColors(geometry, defaultColor);
                applyId(geometry, i);
                geometries.push(geometry);
            }
            
            pickingData[i] = {
                position: position,
                rotation: rotation,
                scale: scale
            };
        }

        const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
        pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));

        highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(),
            new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.FrontSide,
                wireframe: true,
                wireframeLinewidth: 2
            })
        );
        highlightBox.scale.multiplyScalar(1.2);
        highlightBox.visible = false;
        scene.add(highlightBox);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        // Add zoom constraints
        controls.minDistance = 1000;
        controls.maxDistance = 3500;

        // Add event listeners for user interaction
        controls.addEventListener('start', () => {
            stopAutoRotation();
        });

        // Add change event listener to close menu when camera moves
        controls.addEventListener('change', () => {
            closeMenu();
        });

        // Single event listener for pointer down
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        window.addEventListener('resize', onWindowResize);

        stats = new Stats();
        container.appendChild(stats.dom);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerDown(event) {
        event.preventDefault();
        stopAutoRotation();
        
        // Get pointer coordinates
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

        // Perform picking
        pick();

        const currentTime = Date.now();
        const menu = document.getElementById('cube-menu');
        
        if (pickedId !== -1 && !pickingData[pickedId]?.destroyed) {
            if (pickedId === selectedCubeId && currentTime - lastInteractionTime < INTERACTION_TIMEOUT) {
                // Second click on the same cube - show menu at click position
                if (pickedId in cubeBlogMappings) {
                    const clickPosition = {
                        x: event.clientX,
                        y: event.clientY
                    };
                    showCubeMenu(clickPosition);
                } else {
                    // For regular cubes, destroy them
                    destroyCube(pickedId);
                    closeMenu();
                }
            } else {
                // First click - select the cube
                if (menu.style.display === 'block') {
                    closeMenu();
                }
                selectedCubeId = pickedId;
                lastInteractionTime = currentTime;
                
                // Show highlight box
                const data = pickingData[pickedId];
                highlightBox.visible = true;
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                const highlightScale = data.scale.clone().multiplyScalar(1.1);
                highlightBox.scale.copy(highlightScale);
            }
        } else {
            // Clicked empty space or destroyed cube - deselect and hide menu
            if (!menu.contains(event.target)) {
                closeMenu();
            }
        }
    }

    function pick() {
        // render the picking scene off-screen
        const dpr = window.devicePixelRatio;
        
        // Calculate pixel coordinates
        const x = Math.floor((pointer.x + 1) * renderer.domElement.width / 2);
        const y = Math.floor((-pointer.y + 1) * renderer.domElement.height / 2);

        // Set camera view to look at just that pixel
        camera.setViewOffset(
            renderer.domElement.width,
            renderer.domElement.height,
            x,
            y,
            1,
            1
        );

        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickingScene, camera);

        // read the pixel
        const pixelBuffer = new Int32Array(4);
        renderer.readRenderTargetPixels(pickingTexture, 0, 0, 1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        // restore the camera
        camera.clearViewOffset();

        const id = pixelBuffer[0];
        pickedId = id;
    }

    function animate(time) {
        const deltaTime = lastTime ? (time - lastTime) : 0;
        lastTime = time;

        // Check for inactivity
        checkInactivity();

        // Apply auto-rotation if active
        if (autoRotating) {
            scene.rotation.y += autoRotationSpeed;
            pickingScene.rotation.y += autoRotationSpeed;
        }

        // Update fragments
        for (let i = fragments.length - 1; i >= 0; i--) {
            if (fragments[i].update()) {
                fragments.splice(i, 1);
            }
        }

        render();
        stats.update();
    }

    function render() {
        controls.update();
        
        if (highlightBox.visible && pickedId !== -1) {
            const data = pickingData[pickedId];
            if (data) {
                highlightBox.rotation.copy(data.rotation);
            }
        }
        
        renderer.render(scene, camera);
    }

    function showCubeMenu(screenPosition) {
        const menu = document.getElementById('cube-menu');
        const menuTitle = menu.querySelector('.menu-title');
        const menuBrief = menu.querySelector('.menu-brief');
        const menuAuthor = menu.querySelector('.menu-metadata .author');
        const menuDate = menu.querySelector('.menu-metadata .date');
        
        // Set the content from the blog mapping
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            menuTitle.textContent = post.title;
            menuBrief.textContent = post.brief;
            menuAuthor.textContent = post.author;
            menuDate.textContent = post.date;
        }
        
        // Make menu visible but off-screen to measure its dimensions
        menu.style.display = 'block';
        menu.style.left = '-9999px';
        menu.style.top = '-9999px';
        
        // Get menu dimensions
        const menuRect = menu.getBoundingClientRect();
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        
        // Define safe margins
        const TOP_MARGIN = 80; // Space for the upper menu
        const EDGE_MARGIN = 10;
        const SPACING = 20;
        
        // Define center zone boundaries (expanded vertical zone)
        const centerZoneLeft = viewportWidth * 0.4;
        const centerZoneRight = viewportWidth * 0.6;
        const centerZoneTop = viewportHeight * 0.3;    // Expanded vertical center zone
        const centerZoneBottom = viewportHeight * 0.7; // Expanded vertical center zone
        
        // Check if cube is in center zone
        const isInCenterZone = screenPosition.x > centerZoneLeft && 
                              screenPosition.x < centerZoneRight &&
                              screenPosition.y > centerZoneTop &&
                              screenPosition.y < centerZoneBottom;
        
        // Determine if cube is in left/right half of screen
        const isInLeftHalf = screenPosition.x < viewportWidth / 2;
        
        // Calculate vertical center offset
        const verticalCenter = viewportHeight / 2;
        const menuHalfHeight = menuRect.height / 2;
        
        // Calculate optimal position
        let left;
        let top;

        // Horizontal positioning
        if (isInLeftHalf) {
            // Cube is on left, show menu on right
            left = screenPosition.x + SPACING;
        } else {
            // Cube is on right, show menu on left
            left = screenPosition.x - menuRect.width - SPACING;
        }
        
        // Vertical positioning - try to stay close to vertical center
        if (isInCenterZone) {
            // In center zone, align with vertical center
            top = verticalCenter - menuHalfHeight;
        } else {
            // Outside center zone, position relative to click but bias towards center
            const distanceFromCenter = screenPosition.y - verticalCenter;
            const bias = 0.3; // Reduce the offset from center by this factor
            top = verticalCenter + (distanceFromCenter * bias) - menuHalfHeight;
        }
        
        // Ensure menu stays within viewport bounds and below top menu
        if (left < EDGE_MARGIN) {
            left = EDGE_MARGIN;
        } else if (left + menuRect.width > viewportWidth - EDGE_MARGIN) {
            left = viewportWidth - menuRect.width - EDGE_MARGIN;
        }
        
        if (top < TOP_MARGIN) {
            top = TOP_MARGIN;
        } else if (top + menuRect.height > viewportHeight - EDGE_MARGIN) {
            top = viewportHeight - menuRect.height - EDGE_MARGIN;
        }
        
        // Apply final position
        menu.style.left = `${left}px`;
        menu.style.top = `${top}px`;
    }
</script> 