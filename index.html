---
layout: default
---

<div id="container"></div>
<div id="blog-overlay" class="hidden">
    <div class="blog-content">
        <div class="close-button">&times;</div>
        <div id="blog-text">{{ site.posts | first }}</div>
    </div>
</div>

<style>
#container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
}

#blog-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.9);
    z-index: 2;
    display: flex;
    justify-content: center;
    align-items: center;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
}

#blog-overlay.visible {
    opacity: 1;
    pointer-events: auto;
}

.blog-content {
    background: white;
    padding: 2rem;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    max-width: 800px;
    max-height: 80vh;
    overflow-y: auto;
    position: relative;
}

.close-button {
    position: absolute;
    top: 1rem;
    right: 1rem;
    font-size: 1.5rem;
    cursor: pointer;
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background: #f0f0f0;
}

.close-button:hover {
    background: #e0e0e0;
}
</style>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
    import * as THREE from 'three';
    import Stats from 'three/addons/libs/stats.module.js';
    import { TrackballControls } from 'three/addons/controls/TrackballControls.js';
    import * as BufferGeometryUtils from 'three/addons/utils/BufferGeometryUtils.js';

    let container, stats;
    let camera, controls, scene, renderer;
    let pickingTexture, pickingScene;
    let highlightBox;
    let pickedId = -1;
    const fragments = [];
    const gravity = new THREE.Vector3(0, -0.015, 0);
    let lastTime = 0;
    const pickingData = [];
    const pointer = new THREE.Vector2();
    const offset = new THREE.Vector3(10, 10, 10);
    const clearColor = new THREE.Color();
    
    // Auto-rotation variables
    let autoRotating = true;
    let lastInteractionTime = Date.now();
    const INACTIVITY_TIMEOUT = 10000; // 10 seconds
    const autoRotationSpeed = 0.0002; // Slow rotation speed
    
    function startAutoRotation() {
        autoRotating = true;
    }
    
    function stopAutoRotation() {
        autoRotating = false;
        lastInteractionTime = Date.now();
    }
    
    function checkInactivity() {
        if (!autoRotating && Date.now() - lastInteractionTime > INACTIVITY_TIMEOUT) {
            startAutoRotation();
        }
    }

    class Fragment {
        constructor(geometry, material, position, velocity, rotation, customGravity = gravity) {
            this.mesh = new THREE.Mesh(geometry, material);
            this.mesh.position.copy(position);
            this.velocity = velocity;
            this.rotation = rotation;
            this.gravity = customGravity;
            scene.add(this.mesh);
        }

        update() {
            this.velocity.add(this.gravity);
            this.mesh.position.add(this.velocity);
            this.mesh.rotation.x += this.rotation.x;
            this.mesh.rotation.y += this.rotation.y;
            this.mesh.rotation.z += this.rotation.z;

            // Remove if fallen below certain point
            if (this.mesh.position.y < -2000) {
                scene.remove(this.mesh);
                return true;
            }
            return false;
        }
    }

    // Define blog post mappings
    const cubeBlogMappings = {
        42: {
            title: "Welcome to the Interactive Cubes Blog",
            url: "{% post_url 2024-04-09-welcome-to-new-cubes-blog %}",
            color: 0xff0000
        }
        // Add more mappings here for other cubes and posts
    };

    init();
    setupBlogOverlay();

    function setupBlogOverlay() {
        const overlay = document.getElementById('blog-overlay');
        const closeButton = document.querySelector('.close-button');
        
        closeButton.addEventListener('click', () => {
            overlay.classList.remove('visible');
        });

        // Add click event listener to the renderer
        renderer.domElement.addEventListener('click', () => {
            if (pickedId in cubeBlogMappings) {
                showBlogPost();
            } else if (pickedId !== -1) {
                destroyCube(pickedId);
            }
        });
    }

    function showBlogPost() {
        const blogOverlay = document.getElementById('blog-overlay');
        const blogText = document.getElementById('blog-text');
        
        if (pickedId in cubeBlogMappings) {
            const post = cubeBlogMappings[pickedId];
            // The content will be rendered by Jekyll
            blogOverlay.classList.add('visible');
        }
    }

    function destroyCube(id) {
        const data = pickingData[id];
        if (!data) return;

        // Find and remove the original cube from the merged geometry
        scene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                const colors = object.geometry.attributes.color;
                const indices = object.geometry.index.array;
                
                // Find the cube's vertices and hide them
                for (let i = 0; i < vertices.count; i += 24) {  // 24 vertices per cube
                    if (ids[i] === id) {
                        // Hide the vertices by scaling them to 0
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
                
                // Create fragments with parameters based on cube ID
                const destructionType = id % 4; // Use cube ID to determine destruction type
                createFragments(data.position, data.scale, destructionType);
            }
        });

        // Also hide in picking scene
        pickingScene.traverse((object) => {
            if (object.isMesh && object.geometry.attributes.id) {
                const ids = object.geometry.attributes.id.array;
                const vertices = object.geometry.attributes.position;
                
                for (let i = 0; i < vertices.count; i += 24) {
                    if (ids[i] === id) {
                        for (let j = 0; j < 24; j++) {
                            const idx = i + j;
                            vertices.array[idx * 3] = 0;
                            vertices.array[idx * 3 + 1] = 0;
                            vertices.array[idx * 3 + 2] = 0;
                        }
                        break;
                    }
                }
                vertices.needsUpdate = true;
            }
        });

        // Mark this cube as destroyed
        pickingData[id].destroyed = true;
    }

    function createFragments(position, scale, destructionType = 0) {
        // Vary parameters based on destruction type
        const config = {
            0: { // Default
                fragmentCount: 8,
                fragmentSize: 4,
                spread: 2,
                gravity: gravity,
                upwardForce: 2
            },
            1: { // Fast fall, many pieces
                fragmentCount: 12,
                fragmentSize: 5,
                spread: 3,
                gravity: new THREE.Vector3(0, -0.025, 0),
                upwardForce: 1.5
            },
            2: { // Explosive
                fragmentCount: 6,
                fragmentSize: 3,
                spread: 4,
                gravity: new THREE.Vector3(0, -0.01, 0),
                upwardForce: 3
            },
            3: { // Implosive
                fragmentCount: 10,
                fragmentSize: 6,
                spread: 1,
                gravity: new THREE.Vector3(0, -0.02, 0),
                upwardForce: 1
            }
        }[destructionType];

        const fragmentSize = Math.min(scale.x, scale.y, scale.z) / config.fragmentSize;
        
        // Array of possible geometries for fragments
        const geometries = [
            () => new THREE.TetrahedronGeometry(fragmentSize * 0.8),
            () => new THREE.OctahedronGeometry(fragmentSize * 0.7),
            () => new THREE.BoxGeometry(fragmentSize, fragmentSize, fragmentSize),
            () => new THREE.DodecahedronGeometry(fragmentSize * 0.6),
            () => new THREE.IcosahedronGeometry(fragmentSize * 0.7)
        ];

        const fragmentMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            shininess: 0
        });

        // Create fragments with varying count
        for (let i = 0; i < config.fragmentCount; i++) {
            const randomGeometry = geometries[Math.floor(Math.random() * geometries.length)]();
            
            const angle = (i / config.fragmentCount) * Math.PI * 2;
            const radius = fragmentSize * config.spread;
            
            const offset = new THREE.Vector3(
                Math.cos(angle) * radius,
                Math.random() * radius,
                Math.sin(angle) * radius
            );

            const fragmentPos = position.clone().add(offset);
            
            // Adjust velocity based on config
            const velocity = new THREE.Vector3(
                (Math.random() - 0.5) * config.spread,
                Math.random() * config.upwardForce,
                (Math.random() - 0.5) * config.spread
            );

            const rotation = new THREE.Vector3(
                Math.random() * 0.05,
                Math.random() * 0.05,
                Math.random() * 0.05
            );

            fragments.push(new Fragment(
                randomGeometry,
                fragmentMaterial,
                fragmentPos,
                velocity,
                rotation,
                config.gravity // Pass custom gravity to Fragment
            ));
        }
    }

    function init() {
        container = document.getElementById('container');

        // Adjust initial camera position to be closer
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
        camera.position.z = 2000;

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        scene.add(new THREE.AmbientLight(0xcccccc));

        const light = new THREE.DirectionalLight(0xffffff, 3);
        light.position.set(0, 500, 2000);
        scene.add(light);

        const defaultMaterial = new THREE.MeshPhongMaterial({
            color: 0xcccccc,
            flatShading: true,
            vertexColors: false,
            shininess: 0
        });

        pickingScene = new THREE.Scene();
        pickingTexture = new THREE.WebGLRenderTarget(1, 1, {
            type: THREE.IntType,
            format: THREE.RGBAIntegerFormat,
            internalFormat: 'RGBA32I',
        });

        const pickingMaterial = new THREE.ShaderMaterial({
            glslVersion: THREE.GLSL3,
            vertexShader: /* glsl */`
                attribute int id;
                flat varying int vid;
                void main() {
                    vid = id;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: /* glsl */`
                layout(location = 0) out int out_id;
                flat varying int vid;
                void main() {
                    out_id = vid;
                }
            `,
        });

        function applyId(geometry, id) {
            const position = geometry.attributes.position;
            const array = new Int16Array(position.count);
            array.fill(id);
            const bufferAttribute = new THREE.Int16BufferAttribute(array, 1, false);
            bufferAttribute.gpuType = THREE.IntType;
            geometry.setAttribute('id', bufferAttribute);
        }

        function applyVertexColors(geometry, color) {
            const position = geometry.attributes.position;
            const colors = [];
            for (let i = 0; i < position.count; i++) {
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        }

        const geometries = [];
        const matrix = new THREE.Matrix4();
        const quaternion = new THREE.Quaternion();
        const defaultColor = new THREE.Color(0xcccccc);

        for (let i = 0; i < 5000; i++) {
            const geometry = new THREE.BoxGeometry();
            const position = new THREE.Vector3();
            
            if (i in cubeBlogMappings) {
                // Position blog cubes in a circle around the center
                const angle = (i / Object.keys(cubeBlogMappings).length) * Math.PI * 2;
                position.x = Math.cos(angle) * 800;
                position.y = Math.sin(angle) * 800;
                position.z = 500;
            } else {
                position.x = Math.random() * 10000 - 5000;
                position.y = Math.random() * 6000 - 3000;
                position.z = Math.random() * 8000 - 4000;
            }

            const rotation = new THREE.Euler();
            rotation.x = Math.random() * 2 * Math.PI;
            rotation.y = Math.random() * 2 * Math.PI;
            rotation.z = Math.random() * 2 * Math.PI;

            const scale = new THREE.Vector3();
            if (i in cubeBlogMappings) {
                // Make blog cubes a consistent size
                scale.x = scale.y = scale.z = 200;
            } else {
                scale.x = Math.random() * 200 + 100;
                scale.y = Math.random() * 200 + 100;
                scale.z = Math.random() * 200 + 100;
            }

            quaternion.setFromEuler(rotation);
            matrix.compose(position, quaternion, scale);
            geometry.applyMatrix4(matrix);

            // Color special cubes according to their mapping
            if (i in cubeBlogMappings) {
                const blogMaterial = new THREE.MeshPhongMaterial({
                    color: cubeBlogMappings[i].color,
                    flatShading: true,
                    shininess: 30
                });
                applyVertexColors(geometry, new THREE.Color(cubeBlogMappings[i].color));
                applyId(geometry, i);
                
                // Add to both scenes
                const mainMesh = new THREE.Mesh(geometry, blogMaterial);
                const pickingMesh = new THREE.Mesh(geometry.clone(), pickingMaterial);
                
                scene.add(mainMesh);
                pickingScene.add(pickingMesh);
            } else {
                applyVertexColors(geometry, defaultColor);
                applyId(geometry, i);
                geometries.push(geometry);
            }
            
            pickingData[i] = {
                position: position,
                rotation: rotation,
                scale: scale
            };
        }

        const mergedGeometry = BufferGeometryUtils.mergeGeometries(geometries);
        scene.add(new THREE.Mesh(mergedGeometry, defaultMaterial));
        pickingScene.add(new THREE.Mesh(mergedGeometry, pickingMaterial));

        highlightBox = new THREE.Mesh(
            new THREE.BoxGeometry(),
            new THREE.MeshBasicMaterial({ 
                color: 0xff0000,
                side: THREE.FrontSide,
                wireframe: true,
                wireframeLinewidth: 2
            })
        );
        highlightBox.scale.multiplyScalar(1.2);
        highlightBox.visible = false;
        scene.add(highlightBox);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        container.appendChild(renderer.domElement);

        controls = new TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 1.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;
        controls.noZoom = false;
        controls.noPan = false;
        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        // Add zoom constraints
        controls.minDistance = 1000;  // Minimum zoom distance
        controls.maxDistance = 3500;  // Maximum zoom distance

        // Add event listeners for user interaction
        controls.addEventListener('start', () => {
            stopAutoRotation();
        });

        renderer.domElement.addEventListener('pointerdown', () => {
            stopAutoRotation();
        });

        renderer.domElement.addEventListener('wheel', () => {
            stopAutoRotation();
        });

        stats = new Stats();
        container.appendChild(stats.dom);

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        window.addEventListener('resize', onWindowResize);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onPointerMove(event) {
        pointer.x = event.clientX;
        pointer.y = event.clientY;
        pick();
    }

    function pick() {
        // render the picking scene off-screen
        const dpr = window.devicePixelRatio;
        camera.setViewOffset(
            renderer.domElement.width, renderer.domElement.height,
            Math.floor(pointer.x * dpr), Math.floor(pointer.y * dpr),
            1, 1
        );

        renderer.setRenderTarget(pickingTexture);
        renderer.render(pickingScene, camera);

        // read the pixel
        const pixelBuffer = new Int32Array(4);
        renderer.readRenderTargetPixels(pickingTexture, 0, 0, 1, 1, pixelBuffer);
        renderer.setRenderTarget(null);

        // restore the camera
        camera.clearViewOffset();

        const id = pixelBuffer[0];
        pickedId = id;
        
        if (id !== -1 && id !== undefined && id !== null && !pickingData[id]?.destroyed) {
            const data = pickingData[id];
            if (data) {
                highlightBox.position.copy(data.position);
                highlightBox.rotation.copy(data.rotation);
                highlightBox.scale.copy(data.scale).multiplyScalar(1.2);
                highlightBox.visible = true;
            }
        } else {
            highlightBox.visible = false;
        }
    }

    function animate(time) {
        const deltaTime = lastTime ? (time - lastTime) : 0;
        lastTime = time;

        // Check for inactivity
        checkInactivity();

        // Apply auto-rotation if active
        if (autoRotating) {
            scene.rotation.y += autoRotationSpeed;
            pickingScene.rotation.y += autoRotationSpeed;
        }

        // Update fragments
        for (let i = fragments.length - 1; i >= 0; i--) {
            if (fragments[i].update()) {
                fragments.splice(i, 1);
            }
        }

        render();
        stats.update();
    }

    function render() {
        controls.update();
        
        if (highlightBox.visible && pickedId !== -1) {
            const data = pickingData[pickedId];
            if (data) {
                highlightBox.rotation.copy(data.rotation);
            }
        }
        
        renderer.render(scene, camera);
    }
</script> 